#include <assert.h>
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

#include <libcmt/rollup.h>

#include "libcma/parser.h"

void test_ether_deposit(void) {
    cma_parser_input_t parser_input;

    // clang-format off
    uint8_t data_advance1[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // address 20 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, // amount 32 bytes
        // data 0 bytes
    };
    cmt_rollup_advance_t advance1 = {.payload = { .length = sizeof(data_advance1), .data = data_advance1 }};
    // clang-format on

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, NULL, NULL) == -EINVAL);
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, &advance1, NULL) == -EINVAL);
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, NULL, &parser_input) == -EINVAL);
    assert(
        cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, &advance1, &parser_input) == CMA_PARSER_SUCCESS);

    assert(parser_input.type == CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT);

    // clang-format off
    cma_token_address_t address1 = {.data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    }};
    cma_amount_t amount1 = {.data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04,
    }};
    // clang-format on

    assert(memcmp(parser_input.ether_deposit.sender.data, address1.data, CMA_ABI_ADDRESS_LENGTH) == 0);
    assert(memcmp(parser_input.ether_deposit.amount.data, amount1.data, CMA_ABI_U256_LENGTH) == 0);
    assert(parser_input.ether_deposit.exec_layer_data.length == 0);

    // clang-format off
    uint8_t data_advance2[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // address 20 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, // amount 32 bytes
        0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef // data 8 bytes
    };
    cmt_rollup_advance_t advance2 = {.payload = { .length = sizeof(data_advance2), .data = data_advance2 }};
    // clang-format on

    // clang-format off
    uint8_t data2[] = {
        0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef
    };
    // clang-format on

    assert(
        cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, &advance2, &parser_input) == CMA_PARSER_SUCCESS);

    assert(memcmp(parser_input.ether_deposit.sender.data, address1.data, CMA_ABI_ADDRESS_LENGTH) == 0);
    assert(memcmp(parser_input.ether_deposit.amount.data, amount1.data, CMA_ABI_U256_LENGTH) == 0);
    assert(parser_input.ether_deposit.exec_layer_data.length == sizeof(data2));
    assert(memcmp(parser_input.ether_deposit.exec_layer_data.data, data2, sizeof(data2)) == 0);

    // clang-format off
    uint8_t malformed_data_advance1[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,  // address 18 bytes
    };
    uint8_t malformed_data_advance2[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, // address 20 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, // amount 22 bytes
    };
    // clang-format on

    cmt_rollup_advance_t malformed_advance1 = {
        .payload = {.length = sizeof(malformed_data_advance1), .data = malformed_data_advance1}};
    cmt_rollup_advance_t malformed_advance2 = {
        .payload = {.length = sizeof(malformed_data_advance2), .data = malformed_data_advance2}};
    cmt_rollup_advance_t malformed_advance3 = {.payload = {.length = 10, .data = data_advance1}};
    cmt_rollup_advance_t malformed_advance4 = {
        .payload = {.length = sizeof(data_advance2) + 20, .data = data_advance2}};

    assert(
        cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, &malformed_advance1, &parser_input) == -ENOBUFS);

    assert(
        cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, &malformed_advance2, &parser_input) == -ENOBUFS);

    assert(
        cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, &malformed_advance3, &parser_input) == -ENOBUFS);

    // despite being malformed, the parser doesn't give an error because it can't detect (the error is the definition of
    //   the advance input)
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, &malformed_advance4, &parser_input) ==
        CMA_PARSER_SUCCESS);

    printf("%s passed\n", __FUNCTION__);
}

void test_ether_withdraw(void) {
    cma_parser_input_t parser_input;

    // clang-format off
    uint8_t data_advance1[] = {
        0x8c, 0xf7, 0x0f, 0x0b, // funsel
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x11, // amount 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x40, // offset 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, // size 32 bytes
        // data 0 bytes
    };
    // clang-format on
    cmt_rollup_advance_t advance1 = {.payload = {.length = sizeof(data_advance1), .data = data_advance1}};

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, NULL, NULL) == -EINVAL);
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, &advance1, NULL) == -EINVAL);
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, NULL, &parser_input) == -EINVAL);

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, &advance1, &parser_input) ==
        CMA_PARSER_SUCCESS);
    assert(parser_input.type == CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL);

    // clang-format off
    cma_amount_t amount1 = {.data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x11,
    }};
    // clang-format on

    assert(memcmp(parser_input.ether_withdrawal.amount.data, amount1.data, CMA_ABI_U256_LENGTH) == 0);
    assert(parser_input.ether_withdrawal.exec_layer_data.length == 0);

    // clang-format off
    uint8_t data_advance2[] = {
        0x8c, 0xf7, 0x0f, 0x0b, // funsel
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x11, // amount 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x40, // offset 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, // size 32 bytes
        0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef // data 8 bytes
    };
    cmt_rollup_advance_t advance2 = {.payload = { .length = sizeof(data_advance2), .data = data_advance2 }};
    // clang-format on

    // clang-format off
    uint8_t data2[] = {
        0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef
    };
    // clang-format on

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, &advance2, &parser_input) ==
        CMA_PARSER_SUCCESS);

    assert(memcmp(parser_input.ether_withdrawal.amount.data, amount1.data, CMA_ABI_U256_LENGTH) == 0);
    assert(parser_input.ether_withdrawal.exec_layer_data.length == sizeof(data2));
    assert(memcmp(parser_input.ether_withdrawal.exec_layer_data.data, data2, sizeof(data2)) == 0);

    // clang-format off
    uint8_t malformed_data_advance1[] = {
        0x00, 0x00, // funsel
    };
    uint8_t malformed_data_advance2[] = {
        0x00, 0x00, 0x00, 0x00, // wrong funsel
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, // amount 32 bytes
    };
    uint8_t malformed_data_advance3[] = {
        0x8c, 0xf7, 0x0f, 0x0b, // funsel
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, // amount 22 bytes
    };
    // clang-format on

    cmt_rollup_advance_t malformed_advance1 = {
        .payload = {.length = sizeof(malformed_data_advance1), .data = malformed_data_advance1}};
    cmt_rollup_advance_t malformed_advance2 = {
        .payload = {.length = sizeof(malformed_data_advance2), .data = malformed_data_advance2}};
    cmt_rollup_advance_t malformed_advance3 = {
        .payload = {.length = sizeof(malformed_data_advance3), .data = malformed_data_advance3}};
    cmt_rollup_advance_t malformed_advance4 = {.payload = {.length = 10, .data = data_advance1}};
    cmt_rollup_advance_t malformed_advance5 = {
        .payload = {.length = sizeof(data_advance2) + 20, .data = data_advance2}};

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, &malformed_advance1, &parser_input) ==
        -ENOBUFS);

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, &malformed_advance2, &parser_input) ==
        -EBADMSG);

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, &malformed_advance3, &parser_input) ==
        -ENOBUFS);

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, &malformed_advance4, &parser_input) ==
        -ENOBUFS);

    // despite being malformed, the parser doesn't give an error because it wouldn't get
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_WITHDRAWAL, &malformed_advance5, &parser_input) ==
        CMA_PARSER_SUCCESS);

    printf("%s passed\n", __FUNCTION__);
}

void test_ether_transfer(void) {
    cma_parser_input_t parser_input;

    // clang-format off
    uint8_t data_advance1[] = {
        0xff, 0x67, 0xc9, 0x03, // funsel
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, // receiver 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x11, // amount 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x60, // offset 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, // size 32 bytes
        // data 0 bytes
    };
    // clang-format on
    cmt_rollup_advance_t advance1 = {.payload = {.length = sizeof(data_advance1), .data = data_advance1}};

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, NULL, NULL) == -EINVAL);
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, &advance1, NULL) == -EINVAL);
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, NULL, &parser_input) == -EINVAL);

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, &advance1, &parser_input) ==
        CMA_PARSER_SUCCESS);
    assert(parser_input.type == CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER);

    // clang-format off
    cma_amount_t receiver1 = {.data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02,
    }};
    cma_amount_t amount1 = {.data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x11,
    }};
    // clang-format on

    assert(memcmp(parser_input.ether_transfer.receiver.data, receiver1.data, CMA_ABI_ID_LENGTH) == 0);
    assert(memcmp(parser_input.ether_transfer.amount.data, amount1.data, CMA_ABI_U256_LENGTH) == 0);
    assert(parser_input.ether_transfer.exec_layer_data.length == 0);

    // clang-format off
    uint8_t data_advance2[] = {
        0xff, 0x67, 0xc9, 0x03, // funsel
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x02, // receiver 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x11, // amount 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x60, // offset 32 bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x08, // size 32 bytes
        0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef // data 8 bytes
    };
    cmt_rollup_advance_t advance2 = {.payload = { .length = sizeof(data_advance2), .data = data_advance2 }};
    // clang-format on

    // clang-format off
    uint8_t data2[] = {
        0xde, 0xad, 0xbe, 0xef, 0xde, 0xad, 0xbe, 0xef
    };
    // clang-format on

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, &advance2, &parser_input) ==
        CMA_PARSER_SUCCESS);

    assert(memcmp(parser_input.ether_transfer.amount.data, amount1.data, CMA_ABI_U256_LENGTH) == 0);
    assert(parser_input.ether_transfer.exec_layer_data.length == sizeof(data2));
    assert(memcmp(parser_input.ether_transfer.exec_layer_data.data, data2, sizeof(data2)) == 0);

    // clang-format off
    uint8_t malformed_data_advance1[] = {
        0x00, 0x00, // funsel
    };
    uint8_t malformed_data_advance2[] = {
        0x00, 0x00, 0x00, 0x00, // wrong funsel
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, // receiver 32 bytes
    };
    uint8_t malformed_data_advance3[] = {
        0xff, 0x67, 0xc9, 0x03, // funsel
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x04, // receiver 22 bytes
    };
    // clang-format on

    cmt_rollup_advance_t malformed_advance1 = {
        .payload = {.length = sizeof(malformed_data_advance1), .data = malformed_data_advance1}};
    cmt_rollup_advance_t malformed_advance2 = {
        .payload = {.length = sizeof(malformed_data_advance2), .data = malformed_data_advance2}};
    cmt_rollup_advance_t malformed_advance3 = {
        .payload = {.length = sizeof(malformed_data_advance3), .data = malformed_data_advance3}};
    cmt_rollup_advance_t malformed_advance4 = {.payload = {.length = 10, .data = data_advance1}};
    cmt_rollup_advance_t malformed_advance5 = {
        .payload = {.length = sizeof(data_advance2) + 20, .data = data_advance2}};

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, &malformed_advance1, &parser_input) ==
        -ENOBUFS);

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, &malformed_advance2, &parser_input) ==
        -EBADMSG);

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, &malformed_advance3, &parser_input) ==
        -ENOBUFS);

    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, &malformed_advance4, &parser_input) ==
        -ENOBUFS);

    // despite being malformed, the parser doesn't give an error because it wouldn't get
    assert(cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_TRANSFER, &malformed_advance5, &parser_input) ==
        CMA_PARSER_SUCCESS);

    printf("%s passed\n", __FUNCTION__);
}

void test_ether_voucher(void) {
    // clang-format off
    cma_parser_voucher_data_t voucher_req = { .receiver = { .data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, // address 20 bytes
    }}, .ether_voucher_fields = { .amount = { .data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x11, // amount 32 bytes
    }}}};
    uint8_t voucher_payload_buffer[0];
    cma_voucher_t voucher = { .payload = {
        .length = sizeof(voucher_payload_buffer),
        .data = voucher_payload_buffer
    }};
    // clang-format on

    assert(cma_parser_encode_voucher(CMA_PARSER_VOUCHER_TYPE_ETHER, NULL, NULL, NULL) == -EINVAL);
    assert(cma_parser_encode_voucher(CMA_PARSER_VOUCHER_TYPE_ETHER, NULL, &voucher_req, NULL) == -EINVAL);
    assert(cma_parser_encode_voucher(CMA_PARSER_VOUCHER_TYPE_ETHER, NULL, NULL, &voucher) == -EINVAL);

    assert(cma_parser_encode_voucher(CMA_PARSER_VOUCHER_TYPE_NONE, NULL, &voucher_req, &voucher) == -EINVAL);
    assert(
        cma_parser_encode_voucher(CMA_PARSER_VOUCHER_TYPE_ETHER, NULL, &voucher_req, &voucher) == CMA_PARSER_SUCCESS);

    // clang-format off
    cma_abi_address_t receiver1 = {.data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,
    }};
    cma_amount_t amount1 = {.data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x11,
    }};
    // clang-format on

    assert(voucher.payload.length == 0);
    assert(voucher.payload.data == NULL);

    assert(memcmp(voucher.address.data, receiver1.data, sizeof(receiver1)) == 0);
    assert(memcmp(voucher.value.data, amount1.data, sizeof(amount1)) == 0);

    // clang-format off
    cma_abi_address_t address2 = {.data = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23,
    }};
    // clang-format on

    assert(cma_parser_encode_voucher(CMA_PARSER_VOUCHER_TYPE_ETHER, &address2, &voucher_req, &voucher) ==
        CMA_PARSER_SUCCESS);

    printf("%s passed\n", __FUNCTION__);
}

int main(void) {
    test_ether_deposit();
    test_ether_withdraw();
    test_ether_transfer();
    test_ether_voucher();
    printf("All parser tests passed!\n");
    return 0;
}

// printf("sender: ");
// for (size_t i = 0; i < sizeof(parser_input.ether_deposit.sender.data); i++) {
//     printf("%02x", parser_input.ether_deposit.sender.data[i]);
// }
// printf(" = ");
// for (size_t i = 0; i < sizeof(address1.data); i++) {
//     printf("%02x", address1.data[i]);
// }
// printf(" (expected)\n");

// printf("res %d (%s)\n",
//     cma_parser_decode_advance(CMA_PARSER_INPUT_TYPE_ETHER_DEPOSIT, &malformed_advance1, &parser_input),
//     cma_parser_get_last_error_message());
